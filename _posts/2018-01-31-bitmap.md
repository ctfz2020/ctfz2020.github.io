---
title:  Bitmap数据结构与算法研究
tags:
  - Btimap
---

  Bitmap指一维bit数组,数组的元素只有0,1. Bitmap又称为位图,用索引位表示非负整数,对应的bit表示数据的有无.<!--more-->

  例: 0000 0000 0000 0000 0000 0000 0010 0000 方向从右往左,索引位为5的值为1,表示含有数字5

### Bitmap优点

##### 1. 存储紧凑数值空间占用少

  由于使用索引位表示数字,数组的长度n就说明可以表示n个值,32个bit数组就可以表示[0,31]之间的数字,相对于二进制方式,存储的代价降低很多,最小能占用原始大小的1/32.

  例:

int值3二进制表示: 0000 0000 0000 0000 0000 0000 0000 0011

Int值4二进制表示: 0000 0000 0000 0000 0000 0000 0000 0100

Int值5二进制表示: 0000 0000 0000 0000 0000 0000 0000 0101

在bit数组中3,4,5表示: 0000 0000 0000 0000 0000 0000 00001 11000

二进制形式需要占用32*3=96bit,bit数组需要占用32bit,仅为二进制形式的1/3

#####  2. 查找快

查找某个值,只需要查看该值对应数组的索引位上面的值是否是1即可,不需要遍历数组.

#####  3. 支持逻辑运算

因为元素是bit单位,所以两个bitmap可以对元素进行位操作,这个可以用在数据筛选方面.

### Bitmap缺点

##### 1. 存储稀疏数值空间占用大

如果保存数值间隔非常大的数字时,中间需要用0补充,很浪费空间.

例:

Int值1二进制表示:0000 0000 0000 0000 0000 0000 0000 0001

 Int值1000二进制表示:0000 0000 0000 0000 0000 0011 1110 1000

   Bit数组表示:0000 0000 0000 0000 0000 0000 0000 0010

​         .... 省略30个32bit的0

​         0000 0000 0000 0000 0000 0001 0000 0000

 二进制形式需要占用32bit,而bit数组需要占用1024bit,为二进制形式的32倍

##### 2. 插入顺序丢失

由于一维数组只有索引和元素的信息,所以除了索引表示数值,元素表示有无外,没有保存顺序的信息了.

##### 3. 只能保存不重复的值

相同的数值会保存在相同的索引位上面,所以添加重复的值,bit数组不会有变化.

##  WAH算法

WAH充分利用了现代CPU的特性，操作Word要比Byte效率高，所以WAH按照字对齐的方式对bitmap进行分组压缩.

### 解决的问题

上面已经简单的介绍了bitmap,如果使用bitmap保存int值,因为int值的二进制占用32bit,所以可以抽象为比较bitmap的32bit可以保存多少个int值,当int数值间隔为32的时候,bitmap占用大小与二进制形式一样,当数值间隔超过32的时候,在bitmap中平均每个数值占用字节会超过32bit,而WAH算法的会把连续相同的0或1继续压缩.

### 算法简介

![image-20200817150055203](/assets/bitmap-1.png)

1. 把bitmap按每31位分组，每个组称为一个block;

2. 如果block既包含0又包含1，以0+block的内容表示,称为literal words;

3. 如果block只包含0，则以10+n表示，其中n标识后面相同的block数量,称为fill words;

4. 如果block只包含1，则已11+n表示，其中n标识后面相同的block数量,称为fill words;

  注:n使用二进制表示,取值范围为[0, 2^30-1].

### 优点

##### 压缩无效bit

连续的”0”bit可以压缩为一个block,减少存储.

##### 紧凑的有效值支持压缩

连续的”1”bit可以压缩为一个block,使得32bit可以存储更多的数值,最多可以保存	(2^30-1)*31个数字.

### 缺点

##### 随机查找慢

经过压缩,数值与索引不是一一对应,导致每次查找需要解压block.

##### 插入慢

每次插入数值也需要解压,确定要插入的block.

##### 无效bit占用

连续全为0的的block虽然压缩为一个fill words,但是还是会占用一个32bit大小.

例:

Int值1二进制表示: 0000 0000 0000 0000 0000 0000 0000 0001

Int值1000二进制表示:0000 0000 0000 0000 0000 0011 1110 1000

   Bit数组表示: 

![image-20200817150349250](/assets/bitmap-2.png)

二进制形式占用64bit, bit数组占用96bit,第二个32bit表示31个全为0的fill words,属于无效占用.

## CONCISE算法

### 解决的问题

CONCISE算法是WAH算法的升级版,上面提到对于fill words,除了高两位表示特殊含义外,剩余30bit表示数量n,由于2^30是一个非常大的数字,基本用不到,所以继续拆分出position bit,可以解决某些情况下的全”0”block占用字节问题

### 算法简介

在Concise算法中，依然存在literal words和fill words的概念。其中，对于literal words，压缩策略与WAH基本一致，不过有一点差别，Concise置最高位为“1”来表示literal words，“0”表示fill words，对于fill words，除了最高位置“0”，次高位与WAH一致外，紧接着的5bits称为“Position bits”.5bit用二进制表示,范围为[0,31], 0表示不需要反转,剩余[1,31]表示

Block块中哪一个需要反转.

例如数字1,1000保存方式:

![image-20200817150601193](/assets/bitmap-3.png)

### 缺点

##### 随机查找慢

同WAH算法

##### 随机插入慢

CONCISE算法在实现时会记录最后一个值与所在的block,所以顺序插入时可以通过对比最后一个值与block确定要插入的block.但是随机插入还是很慢.

##  ROARING算法

上面介绍的WAH和Concise压缩算法都是基于RLE原理(运行时编码),使用一维数组结构,而ROARING算法使用二维数组结构.

### 算法简介

ROARING算法采用的类似分而治之的思想,对于32bit的整数,高16bit作为array的索引位,初始化时array默认大小为4;低16bit保存在array的元素Container中,如下图:

![image-20200817150738342](/assets/bitmap-4.png)

为了优化占用大小,Container有三种实现方式:

1. ArrayContainer 有序的short数组,初始化长度为4,当Container中数值个数小于4096时使用;

2. BitmapContainer 2^16bit大小的bitmap,当Container中数值个数大于4096时使用,因为4096个short数值占用4096*16=65536bit,正好为bitmap大小,此时再增加元素,使用bitmap结构更好一些;

3.  RunContainer 对ArrayContainer,BitmapContainer 进行压缩产生的对象,不可修改,压缩后的大小可能更大,所以在最终压缩前,会进行压缩前后大小比对,根据比对结果决定是否压缩.

### 算法优势

##### 数据量大时,压缩比高

因为同一个Container内数值高16bit共享,array的设计会使压缩比在0.5左右,当bitmap不会修改时,转换成RunContainer会进一步压缩;

##### 随机查询快

查询时会按照高16bit确定Container,这样解压的数据量会小很多

##### 支持动态压缩

多种数据结构,可根据数据量动态计算空间最优的数据结构

## 参考资料

* http://www.bug1874.com/03-22-2017/bitmap-compress-algorithm.html

* http://blog.csdn.net/njpjsoftdev/article/details/52955638