---
title: JAVA向量化计算
tags:
  - Java
  - SIMD
---

之前我一直认为数据计算上没有办法优化, 直到发现CPU支持SIMD指令, 而这个指令是可以用来批量计算数据.

<!--more-->

## SIMD

近些年CPU为了提升矩阵计算速度, 提供了SIMD指令, 以减少执行指令的方式, 批量计算数据.

>  SIMD全称Single Instruction Multiple Data，单指令多数据流，能够复制多个[操作数](https://baike.baidu.com/item/操作数/7658270)，并把它们打包在大型[寄存器](https://baike.baidu.com/item/寄存器/187682)的一组[指令集](https://baike.baidu.com/item/指令集/238130)。--来自百度百科

举个例子: 将两列数组a,b按照相同的索引位置进行求和, 结果放在另一个数组c中

```
|----|   |----|   |----|
| a1 | + | b1 | = | c1 |
|----|   |----|   |----|
| a2 | + | b2 | = | c2 |
|----|   |----|   |----|
| a3 | + | b3 | = | c3 |
|----|   |----|   |----|
| a4 | + | b4 | = | c4 |
|----|   |----|   |----|
  a        b        c
      循环执行
```

普通方式是将a和b的每个元素进行累加

```
|----|   |----|   |----|
| a1 |   | b1 |   | c1 |
|----|   |----|   |----|
| a2 |   | b2 |   | c2 | 
|----| + |----| = |----|
| a3 |   | b3 |   | c3 |
|----|   |----|   |----|
| a4 |   | b4 |   | c4 |
|----|   |----|   |----|
  a        b        c
        批量执行
```

SIMD指令是把数组a和b全部拷贝到寄存器,然后执行一个指令将所有数据相加,得到数组c. 通过减少指令执行次数, 达到性能提升的目的.

### 怎样在java代码中调用SIMD指令呢? 

首先要编写特定的向量计算代码,并且设置JVM开启优化选项. 经验证, 只有对基础类型数组进行向量操作,并且数组的**索引位置一致**才会触发优化.

常见的JVM会提供SIMD优化,以oracle jdk为例, 提供了`-XX:+UseSuperWord`参数用于开启或关闭优化模式, 默认为开启状态, 将`+`改为`-`为关闭.

#### 如何判断JVM是否进行了优化

判断JVM是否执行SMID优化的方法是打印执行的汇编代码, 查看是否有SIMD指令, JVM提供了`-XX:CompileCommand`参数可以打印指定对应的方法的汇编代码,但是需要hsdis包, 在[FCML](https://sourceforge.net/projects/fcml/files)页面可以下载.

注意: 出现`vmovdqu`,`vpaddq`等指令说明执行了优化, 具体的指令集可以访问[Intel指令大全](https://software.intel.com/sites/landingpage/IntrinsicsGuide)

相关汇编代码如下:

```shell
  0x0000000007f375d7: vmovdqu ymm2,ymmword ptr [r10+rdi*8+10h]
  0x0000000007f375de: vpaddq  ymm1,ymm1,ymm0
  0x0000000007f375e2: vpaddq  ymm2,ymm2,ymm0
  0x0000000007f375e6: vmovdqu ymmword ptr [r11+rdi*8+10h],ymm2
  0x0000000007f375ed: vmovdqu ymmword ptr [r11+rdi*8+30h],ymm1
```

### SIMD性能影响

我们来做个测试, 将数组values的元素+1赋值到数组results中, 观察开启和关闭SMID情况下耗时情况

```java
@State(Scope.Thread)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@BenchmarkMode(Mode.AverageTime)
@Fork(value = 1, jvmArgsAppend = {
        "-XX:+UseSuperWord",
        "-XX:+UnlockDiagnosticVMOptions",
        "-XX:CompileCommand=print,*SIMDBenchmark.increment*"
        })
@Warmup(iterations = 5)
@Measurement(iterations = 10)
public class SIMDBenchmark {
	public static final int SIZE = 1024;
	
	public long[] values = new long[SIZE];
	public long[] results = new long[SIZE];

	@Setup
	public void init() {
		for(int i = 0; i < values.length; i++) {
			values[i] = ThreadLocalRandom.current().nextLong();
		}
	}
	
    @Benchmark
    public void increment(Blackhole hole)
    {
        for (int i = 0; i < SIZE; i++) {
        	results[i] = values[i] + 1;
        }
        hole.consume(results);
    }
    public static void main(String[] args) throws RunnerException {
    	Options opt = new OptionsBuilder()
				.include(SIMDBenchmark.class.getSimpleName())
				.build();
		new Runner(opt).run();
	}
}
```

通过微基准测试, 得到如下结果

![image-20200807165728910](/assets/vector-4.png)

开启SIMD性能提升了3倍以上,提升还是很可观的.

### 使用用例

假设一种场景, 要对数组元素进行求和,分别使用普通的累加,向量累加和关闭向量优化的向量累加的耗时做对比

```java
@State(Scope.Thread)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@BenchmarkMode(Mode.AverageTime)
@Fork(value = 1, jvmArgsAppend = {
        "-XX:+UseSuperWord",
        "-XX:+UnlockDiagnosticVMOptions"
        ,"-XX:CompileCommand=print,*ArraySumBenchmark.vectorSum"
        })
@Warmup(iterations = 3)
@Measurement(iterations = 10)
public class ArraySumBenchmark {
	public static final int SIZE = 1024;
	public int[] values = new int[SIZE * 100];
	
	@Setup
	public void initArray() {
		for(int i = 0; i < values.length; i++) {
			values[i] = ThreadLocalRandom.current().nextInt() / 2;
		}
	}
	
    @Benchmark
    public void simpleLoopSum(Blackhole hole)
    {
       long sum = 0;
       for(int i = 0; i < values.length; i++) {
    		sum += values[i];
       }
        hole.consume(sum);
    }
    
    @Benchmark
    public void vectorSum(Blackhole hole)
    {
    	int[] resultArr = new int[SIZE];
    	int[] tmpArr = new int[SIZE];
		
		int index = 0;
		while(index <= values.length - tmpArr.length) {
			System.arraycopy(values, index, tmpArr, 0, tmpArr.length);
			add(resultArr, tmpArr, 0, tmpArr.length);
			index += tmpArr.length;
		}
		
		long sum = 0;
		for(int i = 0; i < resultArr.length; i++) {
			sum += resultArr[i];
		}
		
		for(; index < values.length; index ++) {
			sum += values[index];
		}
		
    	hole.consume(sum);
    }
	
	public void add(int[] tmp, int[] src, int from, int end) {
		int offset = end - from;
		for(int i = 0; i < offset; i++) {
			tmp[i] = tmp[i] + src[i];
		}
	}

    public static void main(String[] args) throws RunnerException {
    	Options opt = new OptionsBuilder()
				.include(ArraySumBenchmark.class.getSimpleName())
				.build();
		new Runner(opt).run();
	}
}
```

`simpleLoopSum`方法实现为定义变量sum, 循环数组并累加元素, 相比之下`vectorSum`方法实现较为复杂些, 因为待计算数组元素很多, 为了进行向量计算, 将长数组分成了很多小数组, 并将这些小数组进行向量化计算, 中间多了数组拷贝的步骤.

执行完int[]数组后, 将int[]数组换成long[]数组再次执行, 结果如下

![image-20200810160646199](/assets/vector-5.png)

可以看到, 对于int[], 向量化计算耗时比普通循环累加耗时短, 其中增加了数组拷贝的耗时. 对于long[]向量化计算比普通循环累加耗时要长一些,可能是增加数组拷贝耗时比向量优化减少的耗时更多.

### 结论

向量化计算比普通循环处理性能要高, 但是向量化计算的条件要求比较苛刻, 将待计算的数据转换为临时数组也会消耗一定的资源.

引用:

* [SIMD指令集](https://zhuanlan.zhihu.com/p/31271788)
* [JAVA and SIMD](https://prestodb.rocks/code/simd)